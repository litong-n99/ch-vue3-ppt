<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Vue3 develop skill</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

		<style>
			.col-wrapper {
				display: flex;
			}
			.col-block *{
				display: block;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3 style="margin-top: 100px;">Vue3 Develop Skill</h3>
					<p style="margin-top: 100px;">
						<small>Created by <a href="https://github.com/litong-n99" target="_blank">Li Tong</a></small>
					</p>
					<img style="width: 140px;position: relative; top: -50px;" src="assets/ts.png" alt="">
				</section>
				<section>
					<section>
						<h2>Develop Tools-Volar</h2>
					</section>
					<section>
						<ul>
							<li>
								Same like vetur, volar is a vscode extension for vue, but the difference is volar provided more powerful ability.
							</li>
							<li class="fragment">
								Install: Searching in vscode extensions marketing, then you can installing by click
							</li>
						</ul>
						<img class="fragment" src="assets/volar.image" alt="">
					</section>
					<section>
						<h2>Css Programming Enhancement 1</h2>
						<p class="fragment">Volar provided Css Class references hint</p>
						<img class="fragment" src="assets/volar-css1.png">
					</section>
					<section>
						<h2>Css Programming Enhancement 2</h2>
						<p class="fragment">Css Class tracking back</p>
						<img class="fragment" src="assets/volar-css2.image">
					</section>
					<section>
						<h2>Css Programming Enhancement 3</h2>
						<p class="fragment">Css Module type hint</p>
						<img class="fragment" src="assets/volar-css3.png">
					</section>
					<section>
						<h2>Ts static type checking In template tag</h2>
						<p style="font-size: 25px;" class="fragment">Volar provided ability that is Typescript static type checking In Html reader, witch is template tag, not only provided Props, Events and also could type check at V-models</p>
						<p style="font-size: 25px;" class="fragment">Now, we can write the code of Html, and don't worried about our variable spelling goes wrong</p>
						<img class="fragment" src="assets/volar-ts1.png">
					</section>
					<section>
						<h2>Vue-tsc(important)</h2>
						<p style="font-size: 20px;" class="fragment">Volar not only work in vscode, and also had a terminal version, that is Vue-Tsc</p>
						<img style="margin: 0;" class="fragment" src="assets/volar-ts2.png">
						<img class="fragment" src="assets/volar-ts3.png">
					</section>
				</section>
				<section>
					<section>
						<h2>Composition Api/Option Api/Class Component</h2>
					</section>
					<section>
						<h2>Computed</h2>
						<div class="col-wrapper">
							<div class="fragment col-block">
								<span>Option Api</span>
								<img src="assets/compare-computed-oa.png" alt="">
							</div>
							<div class="fragment col-block">
								<span>Composition Api</span>
								<img src="assets/compare-computed-ca.png" alt="">
							</div>
							<div class="fragment col-block">
								<span>Class Component</span>
								<img src="assets/compare-computed-class.png" alt="">
							</div>
						</div>
					</section>
					<section>
						<h2>Event</h2>
						<div class="col-wrapper">
							<div class="fragment col-block">
								<span>Option Api</span>
								<img src="assets/compare-emit-oa.png" alt="">
							</div>
							<div class="fragment col-block">
								<span>Composition Api</span>
								<img src="assets/compare-emit-ca.png" alt="">
							</div>
							<div class="fragment col-block">
								<span>Class Component</span>
								<img src="assets/compare-emit-class.png" alt="">
							</div>
						</div>
					</section>
					<section>
						<h2>Watch</h2>
						<div class="col-wrapper">
							<div class="fragment col-block">
								<span>Option Api</span>
								<img src="assets/compare-watch-oa.png" alt="">
							</div>
							<div class="fragment col-block">
								<span>Composition Api</span>
								<img src="assets/compare-watch-ca.png" alt="">
							</div>
							<div class="fragment col-block">
								<span>Class Component</span>
								<img src="assets/compare-watch-class.png" alt="">
							</div>
						</div>
					</section>
				</section>
				<section>
					<section>
						<h2>Composition Api</h2>
					</section>
					<section>
						<h2>Why Composition Api?</h2>
						<ul>
							<li class="fragment">Composition API is functional programming diagram of Vue Component just lick ReactHooks</li>
							<li class="fragment">It's easy to sharing and reusing the common code in different components and don't worried about VueMixin same-named problem.</li>
							<li class="fragment">BTW, it also can Tree-shacking.</li>
						</ul>
					</section>
					<section>
						<h2>Good / Bad</h2>
						<ul>
							<li class="fragment">Good: Convenient encapsulation, convenient abstraction, and high reusability</li>
							<li class="fragment">Bad 1: Within function, order is very important, because sometimes, variables are dependant each other, and we can't easily moving order of variables </li>
							<li style="font-size: 25px;" class="fragment">Within function, we can't get the variables just like "this.xxx", and only use it after variables declare</li>
							<li class="fragment">Bad 2: Easily to get sub-component variable, even the variables are privete</li>
						</ul>
					</section>
					<section>
						<h2>Compared to ReactHooks</h2>
						<ul>
							<li class="fragment">1. Reduced optimization burden of ReactHook's rerender</li>
							<li style="font-size: 25px;" class="fragment">When ReactHooks rerender, the defined function will be rerun, therefore we need to cooperate with other hooks like useCallback, useMemo. But CompositionApi only run at first time (Equivalent to Created hooks), thereby reduced optimization burden</li>
							<li class="fragment">2.Setup function need to return the necessary variables for the Template or Parent component</li>
							<li style="font-size: 25px;" class="fragment">You can use Setup attribute of Script Tag, that's convenient return all variables.</li>
							<li style="font-size: 25px;" class="fragment">We can get the reference of Component by "const xxxComp = ref&lt;InstanceType&lt;typeof XxxComponent&gt;&gt;();"，and get the variables and methods that sub-component exposed</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Composition Api Demo</h2>
					</section>
					<section>
						<h2>1.useRequest</h2>
						<ul>
							<li>Simplify network request</li>
							<li>Support Loading variable</li>
							<li>Don't need Passing parameters</li>
							<li>Wathcing parmeters change then Request</li>
							<li>Initial Data</li>
						</ul>
					</section>
					<section>
						<h2>2.toPropRef/toModelRef</h2>
						<ul>
							<li>Prevent props tampering</li>
							<li>Simplify V-model Binding</li>
							<li>Auto Sync v-model</li>
						</ul>
					</section>
					<section>
						<h2>3.cacheRef</h2>
						<ul>
							<li>Provided Cache ability for Ref</li>
							<li>Combined with "State Machine", and make it more flexible</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Simple State Machine without Vuex</h2>
					</section>
					<section>
						<h2>1.What is State Machine（FSM）</h2>
						<ul>
							<li style="font-size: 25px;" class="fragment">State: Thing's State, and also is variable store in Frontend</li>
							<li style="font-size: 25px;" class="fragment">Action: Ways to change State</li>
						</ul>
						<img class="fragment" src="assets/fsm-tcp.png" alt="">
					</section>
					<section>
						<h2>2. State Machine in Frontend</h2>
						<ul>
							<li style="font-size: 25px;" class="fragment">Responsive</li>
							<li style="font-size: 25px;" class="fragment">State Readonly</li>
						</ul>
					</section>
					<section>
						<h2>3.state/action</h2>
					</section>
					<section>
						<h2>4.state getter</h2>
					</section>
					<section>
						<h2>5.Persistence</h2>
					</section>
					<section>
						<h2>6.Good / Bad</h2>
						<ul>
							<li class="fragment">Good: Convenient, no more Typescript define</li>
							<li class="fragment">Bad: Can't recording action and tracking back, but if you want, you can make a custom CompositionApi for it</li>
						</ul>
					</section>
				</section>
				<section>
					<h1>Thanks for watching!</h1>
					<p><a href="https://github.com/litong-n99/vue3-demo" target="_blank">Demo Project</a>&<a href="https://litong-n99.github.io/ch-vue3-ppt/index.html#/" target="_blank">PPT</a></p>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				transition: 'convex',

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
